// <auto-generated/>
// Auto-generated added to suppress names errors.

namespace UIWidgets
{
	using System;
	using System.Reflection;
	using System.Collections.Generic;
	using UIWidgets.Extensions;
	using UIWidgets.Styles;
	using UnityEngine;
	using UnityEngine.Events;
	using UnityEngine.EventSystems;
	using UnityEngine.Serialization;
	using UnityEngine.UI;

	/// <summary>
	/// ListViewBase.
	/// You can use it for creating custom ListViews.
	/// </summary>
	public abstract partial class ListViewBase : UIBehaviour,
			ISelectHandler, IDeselectHandler,
			ISubmitHandler, ICancelHandler,
			IStylable, IUpgradeable
	{
		/// <summary>
		/// Selectable target.
		/// </summary>
		protected struct SelectableTarget
		{
			/// <summary>
			/// Score.
			/// </summary>
			public float Score;

			/// <summary>
			/// Target.
			/// </summary>
			public Selectable Target;

			/// <summary>
			/// Constructor.
			/// </summary>
			/// <param name="score">Score.</param>
			/// <param name="target">Target.</param>
			public SelectableTarget(float score, Selectable target = null)
			{
				Score = score;
				Target = target;
			}
		}

		[SerializeField]
		[HideInInspector]
		List<ListViewItem> items = new List<ListViewItem>();

		/// <summary>
		/// Gets or sets the items.
		/// </summary>
		/// <value>Items.</value>
		public List<ListViewItem> Items
		{
			get
			{
				return new List<ListViewItem>(items);
			}

			set
			{
				UpdateComponents(value);
			}
		}

		/// <summary>
		/// The destroy game objects after setting new items.
		/// </summary>
		[SerializeField]
		[HideInInspector]
		public bool DestroyGameObjects = true;

		[SerializeField]
		[FormerlySerializedAs("Multiple")]
		[FormerlySerializedAs("multiple")]
		bool multipleSelect;

		/// <summary>
		/// Allow select multiple items.
		/// </summary>
		public bool MultipleSelect
		{
			get
			{
				return multipleSelect;
			}

			set
			{
				if (!value && selectedIndices.Count > 1)
				{
					var deselect = SelectedIndices;
					for (int i = 0; i < deselect.Count - 1; i++)
					{
						Deselect(deselect[i]);
					}
				}

				multipleSelect = value;
			}
		}

		/// <summary>
		/// Allow select multiple items.
		/// </summary>
		[Obsolete("Use MultipleSelect instead.")]
		public bool Multiple
		{
			get
			{
				return MultipleSelect;
			}

			set
			{
				MultipleSelect = value;
			}
		}

		#if UNITY_EDITOR
		/// <summary>
		/// Validate this instance.
		/// </summary>
		protected override void OnValidate()
		{
			base.OnValidate();
			MultipleSelect = multipleSelect;
		}
		#endif

		[SerializeField]
		int selectedIndex = -1;

		/// <summary>
		/// Gets or sets the index of the selected item.
		/// </summary>
		/// <value>The index of the selected.</value>
		public int SelectedIndex
		{
			get
			{
				return selectedIndex;
			}

			set
			{
				if (value == -1)
				{
					if (selectedIndex != -1)
					{
						Deselect(selectedIndex);
					}

					selectedIndex = value;
				}
				else
				{
					Select(value);
				}
			}
		}

		[SerializeField]
		[FormerlySerializedAs("selectedIndicies")]
		LinkedHashSet<int> selectedIndices = new LinkedHashSet<int>();

		/// <summary>
		/// Gets or sets indices of the selected items.
		/// </summary>
		/// <value>The selected indices.</value>
		public List<int> SelectedIndices
		{
			get
			{
				return selectedIndices.Items();
			}

			set
			{
				var deselect = new List<int>();
				foreach (var index in selectedIndices)
				{
					if (!value.Contains(index))
					{
						deselect.Add(index);
					}
				}

				var select = new List<int>();
				foreach (var index in value)
				{
					if (!selectedIndices.Contains(index))
					{
						select.Add(index);
					}
				}

				deselect.ForEach(Deselect);
				select.ForEach(Select);
			}
		}

		/// <summary>
		/// Gets or sets indices of the selected items.
		/// </summary>
		/// <value>The selected indices.</value>
		[Obsolete("Use SelectedIndices.")]
		public List<int> SelectedIndicies
		{
			get
			{
				return SelectedIndices;
			}

			set
			{
				SelectedIndices = value;
			}
		}

		/// <summary>
		/// Apply style for the table instead of ListView style.
		/// </summary>
		[SerializeField]
		[FormerlySerializedAs("IsTable")]
		[Tooltip("Is ListView will be displayed as a table?\nUsed for correct styles support.")]
		public bool StyleTable;

		/// <summary>
		/// Apply style for the table instead of ListView style.
		/// </summary>
		[Obsolete("Use StyleTable.")]
		public bool IsTable
		{
			get
			{
				return StyleTable;
			}

			set
			{
				StyleTable = value;
			}
		}

		/// <summary>
		/// List can be looped and items is enough to make looped list.
		/// </summary>
		/// <value><c>true</c> if looped list available; otherwise, <c>false</c>.</value>
		public virtual bool LoopedListAvailable
		{
			get
			{
				return false;
			}
		}

		/// <summary>
		/// Allow navigation.
		/// </summary>
		[SerializeField]
		public bool Navigation = true;

		/// <summary>
		/// Navigation settings.
		/// </summary>
		[SerializeField]
		public Navigation NavigationSettings = UnityEngine.UI.Navigation.defaultNavigation;

		/// <summary>
		/// OnSelect event.
		/// </summary>
		[SerializeField]
		public ListViewBaseEvent OnSelect = new ListViewBaseEvent();

		/// <summary>
		/// OnDeselect event.
		/// </summary>
		[SerializeField]
		public ListViewBaseEvent OnDeselect = new ListViewBaseEvent();

		/// <summary>
		/// OnSubmit event.
		/// </summary>
		[SerializeField]
		public UnityEvent onSubmit = new UnityEvent();

		/// <summary>
		/// OnCancel event.
		/// </summary>
		[SerializeField]
		public UnityEvent onCancel = new UnityEvent();

		/// <summary>
		/// OnItemSelect event.
		/// </summary>
		[SerializeField]
		[Obsolete("Replaced with ItemsEvents.Select")]
		public UnityEvent onItemSelect = new UnityEvent();

		/// <summary>
		/// onItemCancel event.
		/// </summary>
		[SerializeField]
		[Obsolete("Replaced with ItemsEvents.Cancel")]
		public UnityEvent onItemCancel = new UnityEvent();

		/// <summary>
		/// The container for items objects.
		/// </summary>
		[SerializeField]
		public Transform Container;

		/// <summary>
		/// OnFocusIn event.
		/// </summary>
		[SerializeField]
		public ListViewFocusEvent OnFocusIn = new ListViewFocusEvent();

		/// <summary>
		/// OnFocusOut event.
		/// </summary>
		[SerializeField]
		public ListViewFocusEvent OnFocusOut = new ListViewFocusEvent();

		/// <summary>
		/// Callback after UpdateView() call.
		/// </summary>
		[SerializeField]
		public UnityEvent OnUpdateView = new UnityEvent();

		/// <summary>
		/// What to do when the event system send a pointer enter Event.
		/// </summary>
		[SerializeField]
		[Obsolete("Replaced with ItemsEvents.PointerEnter.")]
		public ListViewCustomEvent OnPointerEnterObject = new ListViewCustomEvent();

		/// <summary>
		/// What to do when the event system send a pointer exit Event.
		/// </summary>
		[SerializeField]
		[Obsolete("Replaced with ItemsEvents.PointerExit.")]
		public ListViewCustomEvent OnPointerExitObject = new ListViewCustomEvent();

		[SerializeField]
		[HideInInspector]
		GameObject Unused;

		[NonSerialized]
		bool isListViewBaseInited;

		/// <summary>
		/// Determinate if index can be selected.
		/// </summary>
		public Func<int, bool> CanSelect = AlwaysAllow;

		/// <summary>
		/// Determinate if index can be deselected.
		/// </summary>
		public Func<int, bool> CanDeselect = AlwaysAllow;

		/// <summary>
		/// ListViewItem events.
		/// </summary>
		[SerializeField]
		public ListViewItemEvents ItemsEvents = new ListViewItemEvents();

		/// <summary>
		/// Default function to check if index can be selected or deselected.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <returns>true.</returns>
		public static bool AlwaysAllow(int index)
		{
			return true;
		}

		/// <summary>
		/// Start this instance.
		/// </summary>
		public virtual new void Start()
		{
			base.Start();

			Upgrade();
			Init();
		}

		/// <summary>
		/// Init this instance.
		/// </summary>
		public virtual void Init()
		{
			if (isListViewBaseInited)
			{
				return;
			}

			isListViewBaseInited = true;

			Upgrade();

			if (Unused == null)
			{
				Unused = new GameObject("unused base");
				Unused.SetActive(false);
				Unused.transform.SetParent(transform, false);
			}

			if ((selectedIndex != -1) && (selectedIndices.Count == 0))
			{
				selectedIndices.Add(selectedIndex);
			}

			selectedIndices.RemoveWhere(NotIsValid);
			if (selectedIndices.Count == 0)
			{
				selectedIndex = -1;
			}

			OnCanvasGroupChanged();

			AddCallbacks();
		}

		/// <summary>
		/// Determines if item not exists with the specified index.
		/// </summary>
		/// <returns><c>true</c>, if item not exists, <c>false</c> otherwise.</returns>
		/// <param name="index">Index.</param>
		protected bool NotIsValid(int index)
		{
			return !IsValid(index);
		}

		/// <summary>
		/// Is visible item with specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="minVisiblePart">The minimal visible part of the item to consider item visible.</param>
		/// <returns>true if item visible; false otherwise.</returns>
		public virtual bool IsVisible(int index, float minVisiblePart = 0f)
		{
			return false;
		}

		/// <summary>
		/// Is component instance exists for the item with specified index.
		/// </summary>
		/// <returns><c>true</c> if component exists; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		public virtual bool IsItemVisible(int index)
		{
			return false;
		}

		/// <summary>
		/// Determines whether this instance is horizontal. Not implemented for ListViewBase.
		/// </summary>
		/// <returns><c>true</c> if this instance is horizontal; otherwise, <c>false</c>.</returns>
		public virtual bool IsHorizontal()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the default height of the item. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The default item height.</returns>
		public virtual float GetDefaultItemHeight()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the default width of the item. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The default item width.</returns>
		public virtual float GetDefaultItemWidth()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the spacing between items. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The item spacing.</returns>
		public virtual float GetItemSpacing()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the horizontal spacing between items. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The item spacing.</returns>
		public virtual float GetItemSpacingX()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the vertical spacing between items. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The item spacing.</returns>
		public virtual float GetItemSpacingY()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the layout margin.
		/// </summary>
		/// <returns>The layout margin.</returns>
		public virtual Vector4 GetLayoutMargin()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Process the item cancel event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="item">Item.</param>
		/// <param name="eventData">Event data.</param>
		void OnItemCancel(int index, ListViewItem item, BaseEventData eventData)
		{
			if (EventSystem.current.alreadySelecting)
			{
				return;
			}

			EventSystem.current.SetSelectedGameObject(gameObject);

			#pragma warning disable 0618
			onItemCancel.Invoke();
			#pragma warning restore 0618
		}

		/// <summary>
		/// Adds the callbacks.
		/// </summary>
		void AddCallbacks()
		{
			ItemsEvents.Cancel.AddListener(OnItemCancel);
			ItemsEvents.Move.AddListener(OnItemMove);
			ItemsEvents.Select.AddListener(OnItemSelect);
			ItemsEvents.Deselect.AddListener(OnItemDeselect);

			ItemsEvents.PointerEnter.AddListener(OnItemPointerEnter);
			ItemsEvents.PointerExit.AddListener(OnItemPointerExit);
		}

		/// <summary>
		/// Removes the callbacks.
		/// </summary>
		void RemoveCallbacks()
		{
			ItemsEvents.Cancel.RemoveListener(OnItemCancel);
			ItemsEvents.Move.RemoveListener(OnItemMove);
			ItemsEvents.Select.RemoveListener(OnItemSelect);
			ItemsEvents.Deselect.RemoveListener(OnItemDeselect);

			ItemsEvents.PointerEnter.RemoveListener(OnItemPointerEnter);
			ItemsEvents.PointerExit.RemoveListener(OnItemPointerExit);
		}

		/// <summary>
		/// Process the pointer enter callback event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="item">Item.</param>
		/// <param name="eventData">Event data.</param>
		protected virtual void OnItemPointerEnter(int index, ListViewItem item, PointerEventData eventData)
		{
			#pragma warning disable 0618
			OnPointerEnterObject.Invoke(item.Index);
			#pragma warning restore 0618

			if (!IsSelected(item.Index))
			{
				HighlightColoring(item);
				item.StateHighlighted();
			}
		}

		/// <summary>
		/// Process the pointer enter callback event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="item">Item.</param>
		/// <param name="eventData">Event data.</param>
		protected virtual void OnItemPointerExit(int index, ListViewItem item, PointerEventData eventData)
		{
			#pragma warning disable 0618
			OnPointerExitObject.Invoke(item.Index);
			#pragma warning restore 0618

			if (!IsSelected(item.Index))
			{
				DefaultColoring(item);
				item.StateDefault();
			}
		}

		/// <summary>
		/// Process the item select event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="item">Item.</param>
		/// <param name="eventData">Event data.</param>
		protected virtual void OnItemDeselect(int index, ListViewItem item, BaseEventData eventData)
		{
			Coloring(item);
		}

		/// <summary>
		/// Process the item select event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="item">Item.</param>
		/// <param name="eventData">Event data.</param>
		protected virtual void OnItemSelect(int index, ListViewItem item, BaseEventData eventData)
		{
			#pragma warning disable 0618
			onItemSelect.Invoke();
			#pragma warning restore 0618

			HighlightColoring(item);
		}

		/// <summary>
		/// Process the item move event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="item">Item.</param>
		/// <param name="eventData">Event data.</param>
		protected virtual void OnItemMove(int index, ListViewItem item, AxisEventData eventData)
		{
			if (!Navigation)
			{
				return;
			}

			switch (eventData.moveDir)
			{
				case MoveDirection.Left:
					Navigate(eventData, FindSelectableOnLeft());
					break;
				case MoveDirection.Right:
					Navigate(eventData, FindSelectableOnRight());
					break;
				case MoveDirection.Up:
					if (!Navigate(eventData, item.Index - 1))
					{
						Navigate(eventData, FindSelectableOnUp());
					}
					break;
				case MoveDirection.Down:
					if (Navigate(eventData, item.Index + 1))
					{
						Navigate(eventData, FindSelectableOnDown());
					}
					break;
			}
		}

		/// <summary>
		/// Get Selectables components.
		/// </summary>
		/// <returns>Selectables components.</returns>
		protected static Selectable[] GetSelectables()
		{
			var field = typeof(Selectable).GetField("s_Selectables", BindingFlags.Static | BindingFlags.NonPublic);
			return field.GetValue(null) as Selectable[];
		}

		/// <summary>
		/// Find Selectable component at specified direction.
		/// </summary>
		/// <param name="direction">Direction.</param>
		/// <returns>Selectable.</returns>
		protected virtual Selectable FindSelectable(Vector3 direction)
		{
			var target = new SelectableTarget(float.NegativeInfinity);
			var furthest_target = new SelectableTarget(float.NegativeInfinity);

			direction = direction.normalized;
			var local_direction = Quaternion.Inverse(transform.rotation) * direction;
			var position = transform.TransformPoint(GetPointOnRectEdge(transform as RectTransform, local_direction));

			#if UNITY_2020_3_OR_NEWER
			var one_axis = (NavigationSettings.mode == UnityEngine.UI.Navigation.Mode.Vertical)
				|| (NavigationSettings.mode == UnityEngine.UI.Navigation.Mode.Horizontal);
			var wrap = NavigationSettings.wrapAround && one_axis;
			#else
			var wrap = false;
			#endif

			var selectables = GetSelectables();
			if (selectables == null)
			{
				return null;
			}

			var current = GetComponent<Selectable>();

			foreach (var selectable in selectables)
			{
				if (selectable == null)
				{
					continue;
				}

				if (selectable == current)
				{
					continue;
				}

				if (!selectable.IsInteractable())
				{
					continue;
				}

				if (selectable.navigation.mode == UnityEngine.UI.Navigation.Mode.None)
				{
					continue;
				}

				var rt = selectable.transform as RectTransform;

				var center = (rt != null) ? (Vector3)rt.rect.center : Vector3.zero;
				var distance = selectable.transform.TransformPoint(center) - position;
				var dot = Vector3.Dot(direction, distance);

				if (wrap && dot < 0f)
				{
					var score = -dot * distance.sqrMagnitude;
					if (score > furthest_target.Score)
					{
						furthest_target = new SelectableTarget(score, selectable);
					}
				}
				else if (dot > 0f)
				{
					var score = dot / distance.sqrMagnitude;
					if (score > target.Score)
					{
						target = new SelectableTarget(score, selectable);
					}
				}
			}

			if (wrap && (target.Target == null))
			{
				return furthest_target.Target;
			}

			return target.Target;
		}

		/// <summary>
		/// Get point on rect edge.
		/// </summary>
		/// <param name="rect">Rect.</param>
		/// <param name="dir">Direction.</param>
		/// <returns>Point.</returns>
		protected static Vector3 GetPointOnRectEdge(RectTransform rect, Vector2 dir)
		{
			if (rect == null)
			{
				return Vector3.zero;
			}

			if (dir != Vector2.zero)
			{
				dir /= Mathf.Max(Mathf.Abs(dir.x), Mathf.Abs(dir.y));
			}

			return rect.rect.center + Vector2.Scale(rect.rect.size, dir * 0.5f);
		}

		/// <summary>
		/// Find selectable on the left.
		/// </summary>
		/// <returns>Selectable.</returns>
		public virtual Selectable FindSelectableOnLeft()
		{
			if (NavigationSettings.mode == UnityEngine.UI.Navigation.Mode.Explicit)
			{
				return NavigationSettings.selectOnLeft;
			}

			if ((NavigationSettings.mode & UnityEngine.UI.Navigation.Mode.Horizontal) != UnityEngine.UI.Navigation.Mode.None)
			{
				return FindSelectable(transform.rotation * Vector3.left);
			}

			return null;
		}

		/// <summary>
		/// Find selectable on the right.
		/// </summary>
		/// <returns>Selectable.</returns>
		public virtual Selectable FindSelectableOnRight()
		{
			if (NavigationSettings.mode == UnityEngine.UI.Navigation.Mode.Explicit)
			{
				return NavigationSettings.selectOnRight;
			}

			if ((NavigationSettings.mode & UnityEngine.UI.Navigation.Mode.Horizontal) != UnityEngine.UI.Navigation.Mode.None)
			{
				return FindSelectable(transform.rotation * Vector3.right);
			}

			return null;
		}

		/// <summary>
		/// Find selectable on the top.
		/// </summary>
		/// <returns>Selectable.</returns>
		public virtual Selectable FindSelectableOnUp()
		{
			if (NavigationSettings.mode == UnityEngine.UI.Navigation.Mode.Explicit)
			{
				return NavigationSettings.selectOnUp;
			}

			if ((NavigationSettings.mode & UnityEngine.UI.Navigation.Mode.Vertical) != UnityEngine.UI.Navigation.Mode.None)
			{
				return FindSelectable(transform.rotation * Vector3.up);
			}

			return null;
		}

		/// <summary>
		/// Find selectable on the bottom.
		/// </summary>
		/// <returns>Selectable.</returns>
		public virtual Selectable FindSelectableOnDown()
		{
			if (NavigationSettings.mode == UnityEngine.UI.Navigation.Mode.Explicit)
			{
				return NavigationSettings.selectOnDown;
			}

			if ((NavigationSettings.mode & UnityEngine.UI.Navigation.Mode.Vertical) != UnityEngine.UI.Navigation.Mode.None)
			{
				return FindSelectable(transform.rotation * Vector3.down);
			}

			return null;
		}

		/// <summary>
		/// Scrolls to item with specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public virtual void ScrollTo(int index)
		{
		}

		/// <summary>
		/// Add the specified item.
		/// </summary>
		/// <param name="item">Item.</param>
		/// <returns>Index of added item.</returns>
		public virtual int Add(ListViewItem item)
		{
			if (item.transform.parent != Container)
			{
				item.transform.SetParent(Container, false);
			}

			items.Add(item);
			item.Owner = this;
			item.Index = items.Count - 1;

			return items.Count - 1;
		}

		/// <summary>
		/// Clear items of this instance.
		/// </summary>
		public virtual void Clear()
		{
			items.Clear();
			UpdateComponents(items);
		}

		/// <summary>
		/// Remove the specified item.
		/// </summary>
		/// <param name="item">Item.</param>
		/// <returns>Index of removed item.</returns>
		protected virtual int Remove(ListViewItem item)
		{
			var index = item.Index;

			var prev_selected_indices = selectedIndices;
			selectedIndices = new LinkedHashSet<int>();
			foreach (var old_index in prev_selected_indices)
			{
				if (old_index != index)
				{
					selectedIndices.Add(old_index > index ? old_index - 1 : old_index);
				}
			}

			if (selectedIndex == index)
			{
				Deselect(index);
				selectedIndex = selectedIndices.Count > 0 ? selectedIndices.Last() : -1;
			}
			else if (selectedIndex > index)
			{
				selectedIndex -= 1;
			}

			items.Remove(item);
			Free(item);

			return index;
		}

		/// <summary>
		/// Free the specified item.
		/// </summary>
		/// <param name="item">Item.</param>
		void Free(ListViewItem item)
		{
			if (item == null)
			{
				return;
			}

			if ((item.transform == null) || (Unused == null) || (Unused.transform == null))
			{
				return;
			}

			item.Owner = null;
			item.transform.SetParent(Unused.transform, false);
		}

		/// <summary>
		/// Update items.
		/// </summary>
		public abstract void UpdateItems();

		/// <summary>
		/// Updates the items.
		/// </summary>
		/// <param name="newItems">New items.</param>
		protected virtual void UpdateComponents<TItem>(IList<TItem> newItems)
			where TItem : ListViewItem
		{
			if (!ReferenceEquals(items, newItems))
			{
				for (int i = 0; i < items.Count; i++)
				{
					if ((items[i] != null) && (!newItems.Contains(items[i] as TItem)))
					{
						Free(items[i]);
					}
				}
			}

			newItems.ForEach(UpdateItem);

			items.Clear();
			for (int i = 0; i < newItems.Count; i++)
			{
				newItems[i].Owner = this;
				items.Add(newItems[i]);
			}
		}

		void UpdateItem(ListViewItem item, int index)
		{
			if (item == null)
			{
				return;
			}

			item.transform.SetParent(Container, false);
		}

		/// <summary>
		/// Determines if item exists with the specified index.
		/// </summary>
		/// <returns><c>true</c> if item exists with the specified index; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		public virtual bool IsValid(int index)
		{
			return (index >= 0) && (index < items.Count);
		}

		/// <summary>
		/// Gets the item.
		/// </summary>
		/// <returns>The item.</returns>
		/// <param name="index">Index.</param>
		protected ListViewItem GetComponent(int index)
		{
			for (int i = 0; i < items.Count; i++)
			{
				if (items[i].Index == index)
				{
					return items[i];
				}
			}

			return null;
		}

		/// <summary>
		/// Select item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public void Select(int index)
		{
			Select(index, true);
		}

		/// <summary>
		/// Select item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="raiseEvents">Raise select events?</param>
		public virtual void Select(int index, bool raiseEvents)
		{
			if (index < 0)
			{
				return;
			}

			if (!IsValid(index))
			{
				var message = string.Format("Index must be between 0 and Items.Count ({0}), but {2}, Gameobject {1}.", items.Count - 1, name, index);
				throw new IndexOutOfRangeException(message);
			}

			if (IsSelected(index))
			{
				return;
			}

			if (!CanBeSelected(index))
			{
				return;
			}

			if (!MultipleSelect)
			{
				if ((selectedIndex != -1) && (selectedIndex != index))
				{
					Deselect(selectedIndex);
				}

				selectedIndices.Clear();
			}

			selectedIndices.Add(index);
			selectedIndex = index;

			SelectItem(index);

			InvokeSelect(index, raiseEvents);
		}

		/// <summary>
		/// Determines whether if item with specified index can be selected.
		/// </summary>
		/// <returns><c>true</c> if item with specified index can be selected; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		protected virtual bool CanBeSelected(int index)
		{
			return CanSelect(index);
		}

		/// <summary>
		/// Determines whether if item with specified index can be deselected.
		/// </summary>
		/// <returns><c>true</c> if item with specified index can be deselected; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		protected virtual bool CanBeDeselected(int index)
		{
			return CanDeselect(index);
		}

		/// <summary>
		/// Invokes the select event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="raiseEvents">Raise select events?</param>
		protected virtual void InvokeSelect(int index, bool raiseEvents)
		{
			if (!IsValid(index))
			{
				Debug.LogWarning("Incorrect index: " + index, this);
			}

			if (raiseEvents)
			{
				OnSelect.Invoke(index, GetComponent(index));
			}
		}

		/// <summary>
		/// Invokes the deselect event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="raiseEvents">Raise select events?</param>
		protected virtual void InvokeDeselect(int index, bool raiseEvents)
		{
			if (!IsValid(index))
			{
				Debug.LogWarning("Incorrect index: " + index, this);
			}

			if (raiseEvents)
			{
				OnDeselect.Invoke(index, GetComponent(index));
			}
		}

		/// <summary>
		/// Deselect specified indices without raising corresponding events (OnDeselect, etc).
		/// </summary>
		/// <param name="indices">Indices.</param>
		protected virtual void SilentDeselect(IEnumerable<int> indices)
		{
			if (indices == null)
			{
				return;
			}

			foreach (var index in indices)
			{
				selectedIndices.Remove(index);
			}

			selectedIndex = (selectedIndices.Count > 0) ? selectedIndices.Last() : -1;
		}

		/// <summary>
		/// Select specified indices without raising corresponding events (OnSelect, etc).
		/// </summary>
		/// <param name="indixes">Indices.</param>
		protected virtual void SilentSelect(IEnumerable<int> indixes)
		{
			if (indixes == null)
			{
				return;
			}

			indixes.ForEach(selectedIndices.Add);
			selectedIndex = (selectedIndices.Count > 0) ? selectedIndices.Last() : -1;
		}

		/// <summary>
		/// Deselect item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public void Deselect(int index)
		{
			Deselect(index, true);
		}

		/// <summary>
		/// Deselect item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="raiseEvents">Raise select events?</param>
		public void Deselect(int index, bool raiseEvents)
		{
			if (index < 0)
			{
				return;
			}

			if (!IsSelected(index))
			{
				return;
			}

			if (!CanBeDeselected(index))
			{
				return;
			}

			selectedIndices.Remove(index);
			selectedIndex = (selectedIndices.Count > 0) ? selectedIndices.Last() : -1;

			if (IsValid(index))
			{
				DeselectItem(index);

				InvokeDeselect(index, raiseEvents);
			}
		}

		/// <summary>
		/// Determines if item is selected with the specified index.
		/// </summary>
		/// <returns><c>true</c> if item is selected with the specified index; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		public virtual bool IsSelected(int index)
		{
			return selectedIndices.Contains(index);
		}

		/// <summary>
		/// Toggle item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public void Toggle(int index)
		{
			if (IsSelected(index) && MultipleSelect)
			{
				Deselect(index);
			}
			else
			{
				Select(index);
			}
		}

		/// <summary>
		/// Toggle the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public virtual void ItemToggle(int index)
		{
			var shift_pressed = CompatibilityInput.IsShiftPressed;
			var have_selected = selectedIndices.Count > 0;
			var last_selected = selectedIndex;
			if (MultipleSelect && shift_pressed && have_selected && last_selected != index)
			{
				// deselect all items except first
				selectedIndices.Items().ForEach(Deselect);

				// find min and max indices
				var min = Mathf.Min(last_selected, index);
				var max = Mathf.Max(last_selected, index);

				// select items from min to max
				for (int i = min; i < max + 1; i++)
				{
					Select(i);
				}
			}
			else
			{
				Toggle(index);
			}

			if (!IsSelected(index))
			{
				var item = GetComponent(index);
				if (item != null)
				{
					HighlightColoring(item);
				}
			}
		}

		/// <summary>
		/// Move the component transform to the end of the local transform list.
		/// </summary>
		/// <param name="item">Item.</param>
		protected static void SetComponentAsLastSibling(Component item)
		{
			item.transform.SetAsLastSibling();
		}

		/// <summary>
		/// Called when item selected.
		/// Use it for change visible style of selected item.
		/// </summary>
		/// <param name="index">Index.</param>
		protected virtual void SelectItem(int index)
		{
		}

		/// <summary>
		/// Called when item deselected.
		/// Use it for change visible style of deselected item.
		/// </summary>
		/// <param name="index">Index.</param>
		protected virtual void DeselectItem(int index)
		{
		}

		/// <summary>
		/// Updates the colors.
		/// </summary>
		/// <param name="instant">Is should be instant color update?</param>
		public virtual void ComponentsColoring(bool instant = false)
		{
		}

		/// <summary>
		/// Coloring the specified component.
		/// </summary>
		/// <param name="component">Component.</param>
		protected virtual void Coloring(ListViewItem component)
		{
		}

		/// <summary>
		/// Set default colors of specified component.
		/// </summary>
		/// <param name="component">Component.</param>
		protected virtual void DefaultColoring(ListViewItem component)
		{
		}

		/// <summary>
		/// Set highlights colors of specified component.
		/// </summary>
		/// <param name="component">Component.</param>
		protected virtual void HighlightColoring(ListViewItem component)
		{
		}

		/// <summary>
		/// This function is called when the MonoBehaviour will be destroyed.
		/// </summary>
		protected override void OnDestroy()
		{
			base.OnDestroy();

			RemoveCallbacks();

			items.ForEach(Free);
			items.Clear();
		}

		/// <summary>
		/// Set EventSystem.current.SetSelectedGameObject with selected or first item.
		/// </summary>
		/// <returns><c>true</c>, if component was selected, <c>false</c> otherwise.</returns>
		public virtual bool SelectComponent()
		{
			if (items.Count == 0)
			{
				return false;
			}

			var index = (SelectedIndex != -1) ? SelectedIndex : 0;
			SelectComponentByIndex(index);

			return true;
		}

		/// <summary>
		/// Selects the component by index.
		/// </summary>
		/// <param name="index">Index.</param>
		public void SelectComponentByIndex(int index)
		{
			if (!IsValid(index))
			{
				return;
			}

			ScrollTo(index);

			var component = GetComponent(index);
			if (component != null)
			{
				EventSystem.current.SetSelectedGameObject(component.gameObject);
			}
		}

		/// <summary>
		/// Navigate to the specified target.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		/// <param name="target">Target.</param>
		protected virtual void Navigate(AxisEventData eventData, Selectable target)
		{
			if (target != null && target.IsActive())
			{
				eventData.selectedObject = target.gameObject;
			}
		}

		/// <summary>
		/// Navigate to the item with specified index.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		/// <param name="index">Index.</param>
		/// <returns>true if navigation successful; otherwise false.</returns>
		protected virtual bool Navigate(AxisEventData eventData, int index)
		{
			if (!IsValid(index))
			{
				return false;
			}

			ScrollTo(index);

			var component = GetComponent(index);
			if (component == null)
			{
				return false;
			}

			eventData.Use();
			eventData.selectedObject = component.gameObject;

			return true;
		}

		/// <summary>
		/// Selects the component by index.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		/// <param name="index">Index.</param>
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "Reviewed.")]
		public void SelectComponentByIndex(AxisEventData eventData, int index)
		{
			Navigate(eventData, index);
		}

		/// <summary>
		/// Handle select event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		void ISelectHandler.OnSelect(BaseEventData eventData)
		{
			SelectHandlerOnSelect(eventData);
		}

		/// <summary>
		/// Handle select event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		protected virtual void SelectHandlerOnSelect(BaseEventData eventData)
		{
			if (!EventSystem.current.alreadySelecting)
			{
				EventSystem.current.SetSelectedGameObject(gameObject);
			}

			OnFocusIn.Invoke(eventData);
		}

		/// <summary>
		/// Handle deselect event.
		/// </summary>
		/// <param name="eventData">Current event data.</param>
		void IDeselectHandler.OnDeselect(BaseEventData eventData)
		{
			DeselectHandlerOnDeselect(eventData);
		}

		/// <summary>
		/// Handle deselect event.
		/// </summary>
		/// <param name="eventData">Current event data.</param>
		protected virtual void DeselectHandlerOnDeselect(BaseEventData eventData)
		{
			OnFocusOut.Invoke(eventData);
		}

		/// <summary>
		/// Handle submit event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		void ISubmitHandler.OnSubmit(BaseEventData eventData)
		{
			SubmitHandlerOnSubmit(eventData);
		}

		/// <summary>
		/// Handle submit event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		protected virtual void SubmitHandlerOnSubmit(BaseEventData eventData)
		{
			SelectComponent();
			onSubmit.Invoke();
		}

		/// <summary>
		/// Handle cancel event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		void ICancelHandler.OnCancel(BaseEventData eventData)
		{
			CancelHandlerOnCancel(eventData);
		}

		/// <summary>
		/// Handle cancel event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		protected virtual void CancelHandlerOnCancel(BaseEventData eventData)
		{
			onCancel.Invoke();
		}

		/// <summary>
		/// Calls specified function with each component.
		/// </summary>
		/// <param name="func">Function to apply for each component.</param>
		public virtual void ForEachComponent(Action<ListViewItem> func)
		{
			items.ForEach(func);
		}

		/// <summary>
		/// Calls specified function with each component.
		/// </summary>
		/// <param name="func">Function to apply for each component.</param>
		/// <typeparam name="T">Actual type of components.</typeparam>
		protected virtual void ForEachComponent<T>(Action<T> func)
			where T : ListViewItem
		{
			for (int i = 0; i < items.Count; i++)
			{
				func(items[i] as T);
			}
		}

		#region ListViewPaginator support

		/// <summary>
		/// Gets the ScrollRect.
		/// </summary>
		/// <returns>The ScrollRect.</returns>
		public virtual ScrollRect GetScrollRect()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the items count.
		/// </summary>
		/// <returns>The items count.</returns>
		public virtual int GetItemsCount()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the items per block count.
		/// </summary>
		/// <returns>The items per block.</returns>
		public virtual int GetItemsPerBlock()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the item position by index.
		/// </summary>
		/// <returns>The item position.</returns>
		/// <param name="index">Index.</param>
		public virtual float GetItemPosition(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the item position by index.
		/// </summary>
		/// <returns>The item position.</returns>
		/// <param name="index">Index.</param>
		public virtual float GetItemPositionBorderEnd(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the item middle position by index.
		/// </summary>
		/// <returns>The item middle position.</returns>
		/// <param name="index">Index.</param>
		public virtual float GetItemPositionMiddle(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the item bottom position by index.
		/// </summary>
		/// <returns>The item bottom position.</returns>
		/// <param name="index">Index.</param>
		public virtual float GetItemPositionBottom(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest item index.</returns>
		public virtual int GetNearestItemIndex()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the size of the DefaultItem.
		/// </summary>
		/// <returns>Size.</returns>
		public virtual Vector2 GetDefaultItemSize()
		{
			throw new NotSupportedException();
		}

		#endregion

		#region functions to override in ListViewCustom

		/// <summary>
		/// Determines whether is sort enabled.
		/// </summary>
		/// <returns><c>true</c> if is sort enabled; otherwise, <c>false</c>.</returns>
		public virtual bool IsSortEnabled()
		{
			return false;
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest index.</returns>
		/// <param name="eventData">Event data.</param>
		public int GetNearestIndex(PointerEventData eventData)
		{
			if (IsSortEnabled())
			{
				return -1;
			}

			return GetNearestIndex(eventData, NearestType.Auto);
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest index.</returns>
		/// <param name="eventData">Event data.</param>
		/// <param name="type">Preferable nearest index.</param>
		public virtual int GetNearestIndex(PointerEventData eventData, NearestType type)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest item index.</returns>
		/// <param name="point">Point.</param>
		public int GetNearestIndex(Vector2 point)
		{
			return GetNearestIndex(point, NearestType.Auto);
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest item index.</returns>
		/// <param name="point">Point.</param>
		/// <param name="type">Preferable nearest index.</param>
		public virtual int GetNearestIndex(Vector2 point, NearestType type)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Get scroll position.
		/// </summary>
		/// <returns>Position.</returns>
		public virtual float GetScrollPosition()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position.
		/// </summary>
		/// <param name="position">Position.</param>
		public virtual void ScrollToPosition(float position)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position.
		/// </summary>
		/// <param name="position">Position.</param>
		public virtual void ScrollToPosition(Vector2 position)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scroll to specified index with time.
		/// </summary>
		/// <param name="index">Index.</param>
		public virtual void ScrollToAnimated(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position with time.
		/// </summary>
		/// <param name="target">Position.</param>
		public virtual void ScrollToPositionAnimated(float target)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position with time.
		/// </summary>
		/// <param name="target">Position.</param>
		public virtual void ScrollToPositionAnimated(Vector2 target)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Stop scrolling.
		/// </summary>
		public virtual void ScrollStop()
		{
			throw new NotSupportedException();
		}

		#endregion

		#region Interactable

		[SerializeField]
		Color disabledColor = new Color32(200, 200, 200, 128);

		/// <summary>
		/// Gets or sets the disabled color when widget not interactable.
		/// </summary>
		/// <value>The color of the disabled.</value>
		public Color DisabledColor
		{
			get
			{
				return disabledColor;
			}

			set
			{
				if (disabledColor != value)
				{
					disabledColor = value;
					InteractableChanged();
				}
			}
		}

		[SerializeField]
		bool interactable = true;

		/// <summary>
		/// Is widget interactable.
		/// </summary>
		/// <value><c>true</c> if interactable; otherwise, <c>false</c>.</value>
		public bool Interactable
		{
			get
			{
				return interactable;
			}

			set
			{
				if (interactable != value)
				{
					interactable = value;
					InteractableChanged();
				}
			}
		}

		/// <summary>
		/// If the canvas groups allow interaction.
		/// </summary>
		protected bool GroupsAllowInteraction = true;

		/// <summary>
		/// The CanvasGroup cache.
		/// </summary>
		protected readonly List<CanvasGroup> CanvasGroupCache = new List<CanvasGroup>();

		/// <summary>
		/// Process the CanvasGroupChanged event.
		/// </summary>
		protected override void OnCanvasGroupChanged()
		{
			var groupAllowInteraction = true;
			var t = transform;
			while (t != null)
			{
				t.GetComponents(CanvasGroupCache);
				var shouldBreak = false;
				foreach (var canvas_group in CanvasGroupCache)
				{
					if (!canvas_group.interactable)
					{
						groupAllowInteraction = false;
						shouldBreak = true;
					}

					shouldBreak |= canvas_group.ignoreParentGroups;
				}

				if (shouldBreak)
				{
					break;
				}

				t = t.parent;
			}

			if (groupAllowInteraction != GroupsAllowInteraction)
			{
				GroupsAllowInteraction = groupAllowInteraction;
				InteractableChanged();
			}
		}

		/// <summary>
		/// Determines whether this widget is interactable.
		/// </summary>
		/// <returns><c>true</c> if this instance is interactable; otherwise, <c>false</c>.</returns>
		public virtual bool IsInteractable()
		{
			return GroupsAllowInteraction && Interactable;
		}

		/// <summary>
		/// Process interactable change.
		/// </summary>
		protected virtual void InteractableChanged()
		{
			ComponentsColoring(true);

			if (IsInteractable())
			{
				OnInteractableEnabled();
			}
			else
			{
				OnInteractableDisabled();
			}
		}

		/// <summary>
		/// What to do when widget became interactable.
		/// </summary>
		protected virtual void OnInteractableEnabled()
		{
		}

		/// <summary>
		/// What to do when widget became not interactable.
		/// </summary>
		protected virtual void OnInteractableDisabled()
		{
		}
		#endregion

		#region IStylable implementation

		/// <inheritdoc/>
		public virtual bool SetStyle(Style style)
		{
			return false;
		}

		/// <inheritdoc/>
		public virtual bool GetStyle(Style style)
		{
			return false;
		}
		#endregion

		/// <summary>
		/// Upgrade serialized data to the latest version.
		/// </summary>
		public virtual void Upgrade()
		{
		}
	}
}