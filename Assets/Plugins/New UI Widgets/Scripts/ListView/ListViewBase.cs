// <auto-generated/>
// Auto-generated added to suppress names errors.

namespace UIWidgets
{
	using System;
	using System.Collections.Generic;
	using UIWidgets.Styles;
	using UnityEngine;
	using UnityEngine.Events;
	using UnityEngine.EventSystems;
	using UnityEngine.Serialization;
	using UnityEngine.UI;

	/// <summary>
	/// ListViewBase.
	/// You can use it for creating custom ListViews.
	/// </summary>
	public abstract partial class ListViewBase : UIBehaviour,
			ISelectHandler, IDeselectHandler,
			ISubmitHandler, ICancelHandler,
			IStylable, IUpgradeable
	{
		[SerializeField]
		[HideInInspector]
		List<ListViewItem> items = new List<ListViewItem>();

		/// <summary>
		/// Gets or sets the items.
		/// </summary>
		/// <value>Items.</value>
		public List<ListViewItem> Items
		{
			get
			{
				return new List<ListViewItem>(items);
			}

			set
			{
				UpdateComponents(value);
			}
		}

		/// <summary>
		/// The destroy game objects after setting new items.
		/// </summary>
		[SerializeField]
		[HideInInspector]
		public bool DestroyGameObjects = true;

		[SerializeField]
		[FormerlySerializedAs("Multiple")]
		[FormerlySerializedAs("multiple")]
		bool multipleSelect;

		/// <summary>
		/// Allow select multiple items.
		/// </summary>
		public bool MultipleSelect
		{
			get
			{
				return multipleSelect;
			}

			set
			{
				if (!value && selectedIndices.Count > 1)
				{
					var deselect = SelectedIndices;
					for (int i = 0; i < deselect.Count - 1; i++)
					{
						Deselect(deselect[i]);
					}
				}

				multipleSelect = value;
			}
		}

		/// <summary>
		/// Allow select multiple items.
		/// </summary>
		[Obsolete("Use MultipleSelect instead.")]
		public bool Multiple
		{
			get
			{
				return MultipleSelect;
			}

			set
			{
				MultipleSelect = value;
			}
		}

		#if UNITY_EDITOR
		/// <summary>
		/// Validate this instance.
		/// </summary>
		protected override void OnValidate()
		{
			base.OnValidate();
			MultipleSelect = multipleSelect;
		}
		#endif

		[SerializeField]
		int selectedIndex = -1;

		/// <summary>
		/// Gets or sets the index of the selected item.
		/// </summary>
		/// <value>The index of the selected.</value>
		public int SelectedIndex
		{
			get
			{
				return selectedIndex;
			}

			set
			{
				if (value == -1)
				{
					if (selectedIndex != -1)
					{
						Deselect(selectedIndex);
					}

					selectedIndex = value;
				}
				else
				{
					Select(value);
				}
			}
		}

		[SerializeField]
		[FormerlySerializedAs("selectedIndicies")]
		LinkedHashSet<int> selectedIndices = new LinkedHashSet<int>();

		/// <summary>
		/// Gets or sets indices of the selected items.
		/// </summary>
		/// <value>The selected indices.</value>
		public List<int> SelectedIndices
		{
			get
			{
				return selectedIndices.Items();
			}

			set
			{
				var deselect = new List<int>();
				foreach (var index in selectedIndices)
				{
					if (!value.Contains(index))
					{
						deselect.Add(index);
					}
				}

				var select = new List<int>();
				foreach (var index in value)
				{
					if (!selectedIndices.Contains(index))
					{
						select.Add(index);
					}
				}

				deselect.ForEach(Deselect);
				select.ForEach(Select);
			}
		}

		/// <summary>
		/// Gets or sets indices of the selected items.
		/// </summary>
		/// <value>The selected indices.</value>
		[Obsolete("Use SelectedIndices.")]
		public List<int> SelectedIndicies
		{
			get
			{
				return SelectedIndices;
			}

			set
			{
				SelectedIndices = value;
			}
		}

		/// <summary>
		/// Is ListView displayed as table?
		/// Required for style.
		/// </summary>
		[SerializeField]
		[Tooltip("Is ListView will be displayed as a table?\nUsed for correct styles support.")]
		public bool IsTable;

		/// <summary>
		/// Allow navigation.
		/// </summary>
		[SerializeField]
		public bool Navigation = true;

		/// <summary>
		/// OnSelect event.
		/// </summary>
		[SerializeField]
		public ListViewBaseEvent OnSelect = new ListViewBaseEvent();

		/// <summary>
		/// OnDeselect event.
		/// </summary>
		[SerializeField]
		public ListViewBaseEvent OnDeselect = new ListViewBaseEvent();

		/// <summary>
		/// OnSubmit event.
		/// </summary>
		[SerializeField]
		public UnityEvent onSubmit = new UnityEvent();

		/// <summary>
		/// OnCancel event.
		/// </summary>
		[SerializeField]
		public UnityEvent onCancel = new UnityEvent();

		/// <summary>
		/// OnItemSelect event.
		/// </summary>
		[SerializeField]
		public UnityEvent onItemSelect = new UnityEvent();

		/// <summary>
		/// onItemCancel event.
		/// </summary>
		[SerializeField]
		public UnityEvent onItemCancel = new UnityEvent();

		/// <summary>
		/// The container for items objects.
		/// </summary>
		[SerializeField]
		public Transform Container;

		/// <summary>
		/// OnFocusIn event.
		/// </summary>
		[SerializeField]
		public ListViewFocusEvent OnFocusIn = new ListViewFocusEvent();

		/// <summary>
		/// OnFocusOut event.
		/// </summary>
		[SerializeField]
		public ListViewFocusEvent OnFocusOut = new ListViewFocusEvent();

		/// <summary>
		/// Callback after UpdateView() call.
		/// </summary>
		[SerializeField]
		public UnityEvent OnUpdateView = new UnityEvent();

		GameObject Unused;

		[NonSerialized]
		bool isListViewBaseInited;

		/// <summary>
		/// Determinate if index can be selected.
		/// </summary>
		public Func<int, bool> CanSelect = AlwaysAllow;

		/// <summary>
		/// Determinate if index can be deselected.
		/// </summary>
		public Func<int, bool> CanDeselect = AlwaysAllow;

		/// <summary>
		/// Default function to check if index can be selected or deselected.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <returns>true.</returns>
		public static bool AlwaysAllow(int index)
		{
			return true;
		}

		/// <summary>
		/// Start this instance.
		/// </summary>
		public virtual new void Start()
		{
			base.Start();

			Upgrade();
			Init();
		}

		/// <summary>
		/// Init this instance.
		/// </summary>
		public virtual void Init()
		{
			if (isListViewBaseInited)
			{
				return;
			}

			isListViewBaseInited = true;

			Upgrade();

			Unused = new GameObject("unused base");
			Unused.SetActive(false);
			Unused.transform.SetParent(transform, false);

			if ((selectedIndex != -1) && (selectedIndices.Count == 0))
			{
				selectedIndices.Add(selectedIndex);
			}

			selectedIndices.RemoveWhere(NotIsValid);
			if (selectedIndices.Count == 0)
			{
				selectedIndex = -1;
			}

			OnCanvasGroupChanged();
		}

		/// <summary>
		/// Determines if item not exists with the specified index.
		/// </summary>
		/// <returns><c>true</c>, if item not exists, <c>false</c> otherwise.</returns>
		/// <param name="index">Index.</param>
		protected bool NotIsValid(int index)
		{
			return !IsValid(index);
		}

		/// <summary>
		/// Is visible item with specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="minVisiblePart">The minimal visible part of the item to consider item visible.</param>
		/// <returns>true if item visible; false otherwise.</returns>
		public virtual bool IsVisible(int index, float minVisiblePart = 0f)
		{
			return false;
		}

		/// <summary>
		/// Is component instance exists for the item with specified index.
		/// </summary>
		/// <returns><c>true</c> if component exists; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		public virtual bool IsItemVisible(int index)
		{
			return false;
		}

		/// <summary>
		/// Determines whether this instance is horizontal. Not implemented for ListViewBase.
		/// </summary>
		/// <returns><c>true</c> if this instance is horizontal; otherwise, <c>false</c>.</returns>
		public virtual bool IsHorizontal()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the default height of the item. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The default item height.</returns>
		public virtual float GetDefaultItemHeight()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the default width of the item. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The default item width.</returns>
		public virtual float GetDefaultItemWidth()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the spacing between items. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The item spacing.</returns>
		public virtual float GetItemSpacing()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the horizontal spacing between items. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The item spacing.</returns>
		public virtual float GetItemSpacingX()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the vertical spacing between items. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The item spacing.</returns>
		public virtual float GetItemSpacingY()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the layout margin.
		/// </summary>
		/// <returns>The layout margin.</returns>
		public virtual Vector4 GetLayoutMargin()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Removes the callback.
		/// </summary>
		/// <param name="item">Item.</param>
		void RemoveCallback(ListViewItem item)
		{
			if (item == null)
			{
				return;
			}

			item.onClickItem.RemoveListener(Toggle);

			item.onSubmit.RemoveListener(Toggle);
			item.onCancel.RemoveListener(OnItemCancel);

			item.onSelect.RemoveListener(OnItemSelect);
			item.onSelect.RemoveListener(HighlightColoring);
			item.onDeselect.RemoveListener(Coloring);

			item.onMove.RemoveListener(OnItemMove);
		}

		/// <summary>
		/// Process the item cancel event.
		/// </summary>
		/// <param name="item">Item.</param>
		void OnItemCancel(ListViewItem item)
		{
			if (EventSystem.current.alreadySelecting)
			{
				return;
			}

			EventSystem.current.SetSelectedGameObject(gameObject);

			onItemCancel.Invoke();
		}

		/// <summary>
		/// Removes the callbacks.
		/// </summary>
		void RemoveCallbacks()
		{
			items.ForEach(RemoveCallback);
		}

		/// <summary>
		/// Adds the callbacks.
		/// </summary>
		void AddCallbacks()
		{
			items.ForEach(AddCallback);
		}

		/// <summary>
		/// Adds the callback.
		/// </summary>
		/// <param name="item">Item.</param>
		void AddCallback(ListViewItem item)
		{
			item.onClickItem.AddListener(Toggle);

			item.onSubmit.AddListener(OnItemSubmit);
			item.onCancel.AddListener(OnItemCancel);

			item.onSelect.AddListener(OnItemSelect);
			item.onSelect.AddListener(HighlightColoring);
			item.onDeselect.AddListener(Coloring);

			item.onMove.AddListener(OnItemMove);
		}

		/// <summary>
		/// Process the item select event.
		/// </summary>
		/// <param name="item">Item.</param>
		void OnItemSelect(ListViewItem item)
		{
			onItemSelect.Invoke();
		}

		/// <summary>
		/// Process the item submit event.
		/// </summary>
		/// <param name="item">Item.</param>
		void OnItemSubmit(ListViewItem item)
		{
			Toggle(item);
			if (!IsSelected(item.Index))
			{
				HighlightColoring(item);
			}
		}

		/// <summary>
		/// Process the item move event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		/// <param name="item">Item.</param>
		protected virtual void OnItemMove(AxisEventData eventData, ListViewItem item)
		{
			if (!Navigation)
			{
				return;
			}

			switch (eventData.moveDir)
			{
				case MoveDirection.Left:
					break;
				case MoveDirection.Right:
					break;
				case MoveDirection.Up:
					if (IsValid(item.Index - 1))
					{
						SelectComponentByIndex(eventData, item.Index - 1);
					}

					break;
				case MoveDirection.Down:
					if (IsValid(item.Index + 1))
					{
						SelectComponentByIndex(eventData, item.Index + 1);
					}

					break;
			}
		}

		/// <summary>
		/// Scrolls to item with specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public virtual void ScrollTo(int index)
		{
		}

		/// <summary>
		/// Add the specified item.
		/// </summary>
		/// <param name="item">Item.</param>
		/// <returns>Index of added item.</returns>
		public virtual int Add(ListViewItem item)
		{
			if (item.transform.parent != Container)
			{
				item.transform.SetParent(Container, false);
			}

			AddCallback(item);

			items.Add(item);
			item.Index = items.Count - 1;

			return items.Count - 1;
		}

		/// <summary>
		/// Clear items of this instance.
		/// </summary>
		public virtual void Clear()
		{
			items.Clear();
			UpdateComponents(items);
		}

		/// <summary>
		/// Remove the specified item.
		/// </summary>
		/// <param name="item">Item.</param>
		/// <returns>Index of removed item.</returns>
		protected virtual int Remove(ListViewItem item)
		{
			RemoveCallbacks();

			var index = item.Index;

			var prev_selected_indices = selectedIndices;
			selectedIndices = new LinkedHashSet<int>();
			foreach (var old_index in prev_selected_indices)
			{
				if (old_index != index)
				{
					selectedIndices.Add(old_index > index ? old_index - 1 : old_index);
				}
			}

			if (selectedIndex == index)
			{
				Deselect(index);
				selectedIndex = selectedIndices.Count > 0 ? selectedIndices.Last() : -1;
			}
			else if (selectedIndex > index)
			{
				selectedIndex -= 1;
			}

			items.Remove(item);
			Free(item);

			AddCallbacks();

			return index;
		}

		/// <summary>
		/// Free the specified item.
		/// </summary>
		/// <param name="item">Item.</param>
		void Free(Component item)
		{
			if (item == null)
			{
				return;
			}

			if ((item.transform == null) || (Unused == null) || (Unused.transform == null))
			{
				return;
			}

			item.transform.SetParent(Unused.transform, false);
		}

		/// <summary>
		/// Update items.
		/// </summary>
		public abstract void UpdateItems();

		/// <summary>
		/// Updates the items.
		/// </summary>
		/// <param name="newItems">New items.</param>
		protected virtual void UpdateComponents<TItem>(IList<TItem> newItems)
			where TItem : ListViewItem
		{
			RemoveCallbacks();

			if (!ReferenceEquals(items, newItems))
			{
				for (int i = 0; i < items.Count; i++)
				{
					if ((items[i] != null) && (!newItems.Contains(items[i] as TItem)))
					{
						Free(items[i]);
					}
				}
			}

			newItems.ForEach(UpdateItem);

			items.Clear();
			for (int i = 0; i < newItems.Count; i++)
			{
				items.Add(newItems[i]);
			}

			AddCallbacks();
		}

		void UpdateItem(ListViewItem item, int index)
		{
			if (item == null)
			{
				return;
			}

			item.transform.SetParent(Container, false);
		}

		/// <summary>
		/// Determines if item exists with the specified index.
		/// </summary>
		/// <returns><c>true</c> if item exists with the specified index; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		public virtual bool IsValid(int index)
		{
			return (index >= 0) && (index < items.Count);
		}

		/// <summary>
		/// Gets the item.
		/// </summary>
		/// <returns>The item.</returns>
		/// <param name="index">Index.</param>
		protected ListViewItem GetComponent(int index)
		{
			for (int i = 0; i < items.Count; i++)
			{
				if (items[i].Index == index)
				{
					return items[i];
				}
			}

			return null;
		}

		/// <summary>
		/// Select item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public void Select(int index)
		{
			Select(index, true);
		}

		/// <summary>
		/// Select item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="raiseEvents">Raise select events?</param>
		public virtual void Select(int index, bool raiseEvents)
		{
			if (index == -1)
			{
				return;
			}

			if (!IsValid(index))
			{
				var message = string.Format("Index must be between 0 and Items.Count ({0}), but {2}, Gameobject {1}.", items.Count - 1, name, index);
				throw new IndexOutOfRangeException(message);
			}

			if (IsSelected(index))
			{
				return;
			}

			if (!CanBeSelected(index))
			{
				return;
			}

			if (!MultipleSelect)
			{
				if ((selectedIndex != -1) && (selectedIndex != index))
				{
					Deselect(selectedIndex);
				}

				selectedIndices.Clear();
			}

			selectedIndices.Add(index);
			selectedIndex = index;

			SelectItem(index);

			if (raiseEvents)
			{
				InvokeSelect(index);
			}
		}

		/// <summary>
		/// Determines whether if item with specified index can be selected.
		/// </summary>
		/// <returns><c>true</c> if item with specified index can be selected; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		protected virtual bool CanBeSelected(int index)
		{
			return CanSelect(index);
		}

		/// <summary>
		/// Determines whether if item with specified index can be deselected.
		/// </summary>
		/// <returns><c>true</c> if item with specified index can be deselected; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		protected virtual bool CanBeDeselected(int index)
		{
			return CanDeselect(index);
		}

		/// <summary>
		/// Invokes the select event.
		/// </summary>
		/// <param name="index">Index.</param>
		protected virtual void InvokeSelect(int index)
		{
			if (!IsValid(index))
			{
				Debug.LogWarning("Incorrect index: " + index, this);
			}

			OnSelect.Invoke(index, GetComponent(index));
		}

		/// <summary>
		/// Invokes the deselect event.
		/// </summary>
		/// <param name="index">Index.</param>
		protected virtual void InvokeDeselect(int index)
		{
			if (!IsValid(index))
			{
				Debug.LogWarning("Incorrect index: " + index, this);
			}

			OnDeselect.Invoke(index, GetComponent(index));
		}

		/// <summary>
		/// Deselect specified indices without raising corresponding events (OnDeselect, etc).
		/// </summary>
		/// <param name="indices">Indices.</param>
		protected virtual void SilentDeselect(IEnumerable<int> indices)
		{
			if (indices == null)
			{
				return;
			}

			foreach (var index in indices)
			{
				selectedIndices.Remove(index);
			}

			selectedIndex = (selectedIndices.Count > 0) ? selectedIndices.Last() : -1;
		}

		/// <summary>
		/// Select specified indices without raising corresponding events (OnSelect, etc).
		/// </summary>
		/// <param name="indixes">Indices.</param>
		protected virtual void SilentSelect(IEnumerable<int> indixes)
		{
			if (indixes == null)
			{
				return;
			}

			indixes.ForEach(selectedIndices.Add);
			selectedIndex = (selectedIndices.Count > 0) ? selectedIndices.Last() : -1;
		}

		/// <summary>
		/// Deselect item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public void Deselect(int index)
		{
			if (index == -1)
			{
				return;
			}

			if (!IsSelected(index))
			{
				return;
			}

			if (!CanBeDeselected(index))
			{
				return;
			}

			selectedIndices.Remove(index);
			selectedIndex = (selectedIndices.Count > 0) ? selectedIndices.Last() : -1;

			if (IsValid(index))
			{
				DeselectItem(index);

				InvokeDeselect(index);
			}
		}

		/// <summary>
		/// Determines if item is selected with the specified index.
		/// </summary>
		/// <returns><c>true</c> if item is selected with the specified index; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		public virtual bool IsSelected(int index)
		{
			return selectedIndices.Contains(index);
		}

		/// <summary>
		/// Toggle item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public void Toggle(int index)
		{
			if (IsSelected(index) && MultipleSelect)
			{
				Deselect(index);
			}
			else
			{
				Select(index);
			}
		}

		/// <summary>
		/// Toggle the specified item.
		/// </summary>
		/// <param name="item">Item.</param>
		void Toggle(ListViewItem item)
		{
			var shift_pressed = Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift);
			var have_selected = selectedIndices.Count > 0;
			var last_selected = selectedIndex;
			if (MultipleSelect && shift_pressed && have_selected && last_selected != item.Index)
			{
				// deselect all items except first
				selectedIndices.Items().ForEach(Deselect);

				// find min and max indices
				var min = Mathf.Min(last_selected, item.Index);
				var max = Mathf.Max(last_selected, item.Index);

				// select items from min to max
				for (int i = min; i < max + 1; i++)
				{
					Select(i);
				}

				return;
			}

			Toggle(item.Index);
		}

		/// <summary>
		/// Move the component transform to the end of the local transform list.
		/// </summary>
		/// <param name="item">Item.</param>
		protected static void SetComponentAsLastSibling(Component item)
		{
			item.transform.SetAsLastSibling();
		}

		/// <summary>
		/// Called when item selected.
		/// Use it for change visible style of selected item.
		/// </summary>
		/// <param name="index">Index.</param>
		protected virtual void SelectItem(int index)
		{
		}

		/// <summary>
		/// Called when item deselected.
		/// Use it for change visible style of deselected item.
		/// </summary>
		/// <param name="index">Index.</param>
		protected virtual void DeselectItem(int index)
		{
		}

		/// <summary>
		/// Updates the colors.
		/// </summary>
		/// <param name="instant">Is should be instant color update?</param>
		public virtual void ComponentsColoring(bool instant = false)
		{
		}

		/// <summary>
		/// Coloring the specified component.
		/// </summary>
		/// <param name="component">Component.</param>
		protected virtual void Coloring(ListViewItem component)
		{
		}

		/// <summary>
		/// Set highlights colors of specified component.
		/// </summary>
		/// <param name="component">Component.</param>
		protected virtual void HighlightColoring(ListViewItem component)
		{
		}

		/// <summary>
		/// This function is called when the MonoBehaviour will be destroyed.
		/// </summary>
		protected override void OnDestroy()
		{
			base.OnDestroy();

			RemoveCallbacks();

			items.ForEach(Free);
		}

		/// <summary>
		/// Set EventSystem.current.SetSelectedGameObject with selected or first item.
		/// </summary>
		/// <returns><c>true</c>, if component was selected, <c>false</c> otherwise.</returns>
		public virtual bool SelectComponent()
		{
			if (items.Count == 0)
			{
				return false;
			}

			var index = (SelectedIndex != -1) ? SelectedIndex : 0;
			SelectComponentByIndex(index);

			return true;
		}

		/// <summary>
		/// Selects the component by index.
		/// </summary>
		/// <param name="index">Index.</param>
		public void SelectComponentByIndex(int index)
		{
			if (!IsValid(index))
			{
				return;
			}

			ScrollTo(index);

			var component = GetComponent(index);
			if (component != null)
			{
				EventSystem.current.SetSelectedGameObject(component.gameObject);
			}
		}

		/// <summary>
		/// Selects the component by index.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		/// <param name="index">Index.</param>
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "Reviewed.")]
		public void SelectComponentByIndex(AxisEventData eventData, int index)
		{
			if (!IsValid(index))
			{
				return;
			}

			ScrollTo(index);

			var component = GetComponent(index);
			if (component != null)
			{
				eventData.selectedObject = component.gameObject;
			}
		}

		/// <summary>
		/// Handle select event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		void ISelectHandler.OnSelect(BaseEventData eventData)
		{
			SelectHandlerOnSelect(eventData);
		}

		/// <summary>
		/// Handle select event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		protected virtual void SelectHandlerOnSelect(BaseEventData eventData)
		{
			if (!EventSystem.current.alreadySelecting)
			{
				EventSystem.current.SetSelectedGameObject(gameObject);
			}

			OnFocusIn.Invoke(eventData);
		}

		/// <summary>
		/// Handle deselect event.
		/// </summary>
		/// <param name="eventData">Current event data.</param>
		void IDeselectHandler.OnDeselect(BaseEventData eventData)
		{
			DeselectHandlerOnDeselect(eventData);
		}

		/// <summary>
		/// Handle deselect event.
		/// </summary>
		/// <param name="eventData">Current event data.</param>
		protected virtual void DeselectHandlerOnDeselect(BaseEventData eventData)
		{
			OnFocusOut.Invoke(eventData);
		}

		/// <summary>
		/// Handle submit event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		void ISubmitHandler.OnSubmit(BaseEventData eventData)
		{
			SubmitHandlerOnSubmit(eventData);
		}

		/// <summary>
		/// Handle submit event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		protected virtual void SubmitHandlerOnSubmit(BaseEventData eventData)
		{
			SelectComponent();
			onSubmit.Invoke();
		}

		/// <summary>
		/// Handle cancel event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		void ICancelHandler.OnCancel(BaseEventData eventData)
		{
			CancelHandlerOnCancel(eventData);
		}

		/// <summary>
		/// Handle cancel event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		protected virtual void CancelHandlerOnCancel(BaseEventData eventData)
		{
			onCancel.Invoke();
		}

		/// <summary>
		/// Calls specified function with each component.
		/// </summary>
		/// <param name="func">Function to apply for each component.</param>
		public virtual void ForEachComponent(Action<ListViewItem> func)
		{
			items.ForEach(func);
		}

		/// <summary>
		/// Calls specified function with each component.
		/// </summary>
		/// <param name="func">Function to apply for each component.</param>
		/// <typeparam name="T">Actual type of components.</typeparam>
		protected virtual void ForEachComponent<T>(Action<T> func)
			where T : ListViewItem
		{
			for (int i = 0; i < items.Count; i++)
			{
				func(items[i] as T);
			}
		}

		#region ListViewPaginator support

		/// <summary>
		/// Gets the ScrollRect.
		/// </summary>
		/// <returns>The ScrollRect.</returns>
		public virtual ScrollRect GetScrollRect()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the items count.
		/// </summary>
		/// <returns>The items count.</returns>
		public virtual int GetItemsCount()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the items per block count.
		/// </summary>
		/// <returns>The items per block.</returns>
		public virtual int GetItemsPerBlock()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the item position by index.
		/// </summary>
		/// <returns>The item position.</returns>
		/// <param name="index">Index.</param>
		public virtual float GetItemPosition(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the item position by index.
		/// </summary>
		/// <returns>The item position.</returns>
		/// <param name="index">Index.</param>
		public virtual float GetItemPositionBorderEnd(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the item middle position by index.
		/// </summary>
		/// <returns>The item middle position.</returns>
		/// <param name="index">Index.</param>
		public virtual float GetItemPositionMiddle(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the item bottom position by index.
		/// </summary>
		/// <returns>The item bottom position.</returns>
		/// <param name="index">Index.</param>
		public virtual float GetItemPositionBottom(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest item index.</returns>
		public virtual int GetNearestItemIndex()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the size of the DefaultItem.
		/// </summary>
		/// <returns>Size.</returns>
		public virtual Vector2 GetDefaultItemSize()
		{
			throw new NotSupportedException();
		}

		#endregion

		#region functions to override in ListViewCustom

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest index.</returns>
		/// <param name="eventData">Event data.</param>
		public int GetNearestIndex(PointerEventData eventData)
		{
			return GetNearestIndex(eventData, NearestType.Auto);
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest index.</returns>
		/// <param name="eventData">Event data.</param>
		/// <param name="type">Preferable nearest index.</param>
		public virtual int GetNearestIndex(PointerEventData eventData, NearestType type)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest item index.</returns>
		/// <param name="point">Point.</param>
		public int GetNearestIndex(Vector2 point)
		{
			return GetNearestIndex(point, NearestType.Auto);
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest item index.</returns>
		/// <param name="point">Point.</param>
		/// <param name="type">Preferable nearest index.</param>
		public virtual int GetNearestIndex(Vector2 point, NearestType type)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Get scroll position.
		/// </summary>
		/// <returns>Position.</returns>
		public virtual float GetScrollPosition()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position.
		/// </summary>
		/// <param name="position">Position.</param>
		public virtual void ScrollToPosition(float position)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position.
		/// </summary>
		/// <param name="position">Position.</param>
		public virtual void ScrollToPosition(Vector2 position)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scroll to specified index with time.
		/// </summary>
		/// <param name="index">Index.</param>
		public virtual void ScrollToAnimated(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position with time.
		/// </summary>
		/// <param name="target">Position.</param>
		public virtual void ScrollToPositionAnimated(float target)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position with time.
		/// </summary>
		/// <param name="target">Position.</param>
		public virtual void ScrollToPositionAnimated(Vector2 target)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Stop scrolling.
		/// </summary>
		public virtual void ScrollStop()
		{
			throw new NotSupportedException();
		}

		#endregion

		#region Interactable

		[SerializeField]
		Color disabledColor = new Color32(200, 200, 200, 128);

		/// <summary>
		/// Gets or sets the disabled color when widget not interactable.
		/// </summary>
		/// <value>The color of the disabled.</value>
		public Color DisabledColor
		{
			get
			{
				return disabledColor;
			}

			set
			{
				if (disabledColor != value)
				{
					disabledColor = value;
					InteractableChanged();
				}
			}
		}

		[SerializeField]
		bool interactable = true;

		/// <summary>
		/// Is widget interactable.
		/// </summary>
		/// <value><c>true</c> if interactable; otherwise, <c>false</c>.</value>
		public bool Interactable
		{
			get
			{
				return interactable;
			}

			set
			{
				if (interactable != value)
				{
					interactable = value;
					InteractableChanged();
				}
			}
		}

		/// <summary>
		/// If the canvas groups allow interaction.
		/// </summary>
		protected bool GroupsAllowInteraction = true;

		/// <summary>
		/// The CanvasGroup cache.
		/// </summary>
		protected readonly List<CanvasGroup> CanvasGroupCache = new List<CanvasGroup>();

		/// <summary>
		/// Process the CanvasGroupChanged event.
		/// </summary>
		protected override void OnCanvasGroupChanged()
		{
			var groupAllowInteraction = true;
			var t = transform;
			while (t != null)
			{
				t.GetComponents(CanvasGroupCache);
				var shouldBreak = false;
				foreach (var canvas_group in CanvasGroupCache)
				{
					if (!canvas_group.interactable)
					{
						groupAllowInteraction = false;
						shouldBreak = true;
					}

					shouldBreak |= canvas_group.ignoreParentGroups;
				}

				if (shouldBreak)
				{
					break;
				}

				t = t.parent;
			}

			if (groupAllowInteraction != GroupsAllowInteraction)
			{
				GroupsAllowInteraction = groupAllowInteraction;
				InteractableChanged();
			}
		}

		/// <summary>
		/// Determines whether this widget is interactable.
		/// </summary>
		/// <returns><c>true</c> if this instance is interactable; otherwise, <c>false</c>.</returns>
		public virtual bool IsInteractable()
		{
			return GroupsAllowInteraction && Interactable;
		}

		/// <summary>
		/// Process interactable change.
		/// </summary>
		protected virtual void InteractableChanged()
		{
			ComponentsColoring(true);

			if (IsInteractable())
			{
				OnInteractableEnabled();
			}
			else
			{
				OnInteractableDisabled();
			}
		}

		/// <summary>
		/// What to do when widget became interactable.
		/// </summary>
		protected virtual void OnInteractableEnabled()
		{
		}

		/// <summary>
		/// What to do when widget became not interactable.
		/// </summary>
		protected virtual void OnInteractableDisabled()
		{
		}
		#endregion

		#region IStylable implementation

		/// <summary>
		/// Set the specified style.
		/// </summary>
		/// <returns><c>true</c>, if style was set for children gameobjects, <c>false</c> otherwise.</returns>
		/// <param name="style">Style data.</param>
		public virtual bool SetStyle(Style style)
		{
			return false;
		}

		#endregion

		/// <summary>
		/// Upgrade serialized data to the latest version.
		/// </summary>
		public virtual void Upgrade()
		{
		}
	}
}